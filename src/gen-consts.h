static const char sheaderp1[] =
"#ifndef CONFCONF_HEAD_H\n"
"#define CONFCONF_HEAD_H\n"
"\n"
"#include <stdbool.h>\n"
"#include <stdlib.h>\n"
"#include <stdio.h>\n"
"\n"
"#ifndef CONFCONF_ALLOCWIDTH\n"
"#define CONFCONF_ALLOCWIDTH 32\n"
"#endif\n"
"\n"
"enum confconf_result_type {\n"
"	CONFCONF_SUCCESS = 0,\n"
"	CONFCONF_ERR_UNEXPECTED_EOF,\n"
"	CONFCONF_ERR_UNEXPECTED_TOKEN,\n"
"	CONFCONF_ERR_HASH_DUPLICATE_KEY,\n"
"	CONFCONF_ERR_RANGE,\n"
"	CONFCONF_ERR_MISSING_VARIABLE,\n"
"	CONFCONF_ERR_MEMORY,\n"
"	CONFCONF_ERR_BAD_ALLOC_WIDTH,\n"
"};\n"
"\n"
"struct confconf_priv_state {\n"
"	void *fp;\n"
"	int (*gcp)(void *);\n"
"	int (*ugcp)(int, void *);\n"
"	size_t line;\n"
"	size_t col;\n"
"	size_t byte;\n"
"	union {\n"
"		bool b;\n"
"		char *s;\n"
"		int i;\n"
"		long int il;\n"
"		long long int ill;\n"
"		unsigned u;\n"
"		long unsigned ul;\n"
"		long long unsigned ull;\n"
"		float f;\n"
"		double d;\n"
"		long double dl;\n"
"	} val;\n"
"};\n"
"\n"
"static int confconf_priv_gcp_file(void *fp)\n"
"{\n"
"	return getc((FILE *)fp);\n"
"}\n"
"\n"
"static int confconf_priv_ugcp_file(int c, void *fp)\n"
"{\n"
"	return ungetc(c, (FILE *)fp);\n"
"}\n"
"\n"
"static void confconf_priv_eat_space(struct confconf_priv_state *st)\n"
"{\n"
"	int c;\n"
"\n"
"	while (true) {\n"
"		c = (*(st->gcp))(st->fp);\n"
"\n"
"		/* comment */\n"
"		if (c == '#') {\n"
"			st->col++;\n"
"			st->byte++;\n"
"\n"
"			do {\n"
"				c = (*(st->gcp))(st->fp);\n"
"				st->col++;\n"
"				st->byte++;\n"
"			} while (c != '\\n' && c != EOF);\n"
"\n"
"			if (c == '\\n') {\n"
"				st->col = 1;\n"
"				st->line++;\n"
"				continue;\n"
"			} else {\n"
"				st->col--;\n"
"				st->byte--;\n"
"				return;\n"
"			}\n"
"		}\n"
"\n"
"		/* space */\n"
"		if (c == ' ' || c == '\\f' || c == '\\n'\n"
"				|| c == '\\r' || c == '\\t' || c == '\\v') {\n"
"			while (c == ' ' || c == '\\f' || c == '\\n'\n"
"					|| c == '\\r' || c == '\\t' || c == '\\v') {\n"
"				if (c == '\\n') {\n"
"					st->col = 1;\n"
"					st->line++;\n"
"				} else {\n"
"					st->col++;\n"
"				}\n"
"				st->byte++;\n"
"\n"
"				c = (*(st->gcp))(st->fp);\n"
"			}\n"
"\n"
"			if (c == EOF) {\n"
"				return;\n"
"			} else {\n"
"				(*(st->ugcp))(c, st->fp);\n"
"				continue;\n"
"			}\n"
"		}\n"
"\n"
"		(*(st->ugcp))(c, st->fp);\n"
"		break;\n"
"	}\n"
"}\n"
"\n"
;

static const char sheaderp2[] =
"static enum confconf_result_type confconf_priv_get_tok(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	size_t len = 0, mlen = CONFCONF_ALLOCWIDTH;\n"
"	char *stmp;\n"
"	int c;\n"
"\n"
"	st->val.s = NULL;\n"
"\n"
"	c = (*(st->gcp))(st->fp);\n"
"\n"
"	if (c == EOF)\n"
"		return CONFCONF_ERR_UNEXPECTED_EOF;\n"
"\n"
"	st->val.s = realloc(st->val.s, mlen);\n"
"	if (st->val.s == NULL)\n"
"		return CONFCONF_ERR_MEMORY;\n"
"	st->val.s[0] = '\\0';\n"
"\n"
"	while (c != ' ' && c != '\\f' && c != '\\n'\n"
"			&& c != '\\r' && c != '\\t' && c != '\\v'\n"
"			&& c != ']' && c != '}'\n"
"			&& c != '[' && c != '{'\n"
"			&& c != ',' && c != ':'\n"
"			&& c != EOF) {\n"
"		if (len == mlen) {\n"
"			mlen += CONFCONF_ALLOCWIDTH;\n"
"\n"
"			if (mlen < len) {\n"
"				if (st->val.s != NULL) {\n"
"					free(st->val.s);\n"
"					st->val.s = NULL;\n"
"				}\n"
"				return CONFCONF_ERR_MEMORY;\n"
"			}\n"
"\n"
"			stmp = realloc(st->val.s, mlen);\n"
"			if (stmp == NULL) {\n"
"				free(st->val.s);\n"
"				st->val.s = NULL;\n"
"				return CONFCONF_ERR_MEMORY;\n"
"			}\n"
"			st->val.s = stmp;\n"
"		}\n"
"\n"
"		st->val.s[len] = c;\n"
"		len++;\n"
"		c = (*(st->gcp))(st->fp);\n"
"	}\n"
"\n"
"	if (st->val.s[0] == '\\0') {\n"
"		st->val.s[0] = c;\n"
"		len++;\n"
"		if (len == mlen) {\n"
"			mlen += CONFCONF_ALLOCWIDTH;\n"
"\n"
"			if (mlen < len) {\n"
"				if (st->val.s != NULL) {\n"
"					free(st->val.s);\n"
"					st->val.s = NULL;\n"
"				}\n"
"				return CONFCONF_ERR_MEMORY;\n"
"			}\n"
"\n"
"			stmp = realloc(st->val.s, mlen);\n"
"			if (stmp == NULL) {\n"
"				free(st->val.s);\n"
"				st->val.s = NULL;\n"
"				return CONFCONF_ERR_MEMORY;\n"
"			}\n"
"			st->val.s = stmp;\n"
"		}\n"
"		st->val.s[1] = '\\0';\n"
"		return CONFCONF_SUCCESS;\n"
"	}\n"
"\n"
"	if (len == mlen) {\n"
"		mlen += CONFCONF_ALLOCWIDTH;\n"
"\n"
"		if (mlen < len) {\n"
"			if (st->val.s != NULL) {\n"
"				free(st->val.s);\n"
"				st->val.s = NULL;\n"
"			}\n"
"			return CONFCONF_ERR_MEMORY;\n"
"		}\n"
"\n"
"		stmp = realloc(st->val.s, mlen);\n"
"		if (stmp == NULL) {\n"
"			free(st->val.s);\n"
"			st->val.s = NULL;\n"
"			return CONFCONF_ERR_MEMORY;\n"
"		}\n"
"		st->val.s = stmp;\n"
"	}\n"
"\n"
"	(*(st->ugcp))(c, st->fp);\n"
"\n"
"	st->val.s[len] = '\\0';\n"
"\n"
"	st->col += len;\n"
"	st->byte += len;\n"
"\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"static enum confconf_result_type confconf_priv_get_id(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	char *off;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	for (off = st->val.s; *off != '\\0'; off++) {\n"
"		if (*off >= '0' && *off <= '9')\n"
"			continue;\n"
"		if (\n"
"				*off == 'a' || *off == 'b' || *off == 'c' ||\n"
"				*off == 'd' || *off == 'e' || *off == 'f' ||\n"
"				*off == 'g' || *off == 'h' || *off == 'i' ||\n"
"				*off == 'j' || *off == 'k' || *off == 'l' ||\n"
"				*off == 'm' || *off == 'n' || *off == 'o' ||\n"
"				*off == 'p' || *off == 'q' || *off == 'r' ||\n"
"				*off == 's' || *off == 't' || *off == 'u' ||\n"
"				*off == 'v' || *off == 'w' || *off == 'x' ||\n"
"				*off == 'y' || *off == 'z' ||\n"
"				*off == 'A' || *off == 'B' || *off == 'C' ||\n"
"				*off == 'D' || *off == 'E' || *off == 'F' ||\n"
"				*off == 'G' || *off == 'H' || *off == 'I' ||\n"
"				*off == 'J' || *off == 'K' || *off == 'L' ||\n"
"				*off == 'M' || *off == 'N' || *off == 'O' ||\n"
"				*off == 'P' || *off == 'Q' || *off == 'R' ||\n"
"				*off == 'S' || *off == 'T' || *off == 'U' ||\n"
"				*off == 'V' || *off == 'W' || *off == 'X' ||\n"
"				*off == 'Y' || *off == 'Z' ||\n"
"				*off == '-' || *off == '_'\n"
"		) {\n"
"		   continue;\n"
"		}\n"
"				\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"	}\n"
"\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char sbool[] =
"#ifndef CONFCONF_BOOL_H\n"
"#define CONFCONF_BOOL_H\n"
"\n"
"static enum confconf_result_type confconf_priv_get_bool(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	char *off;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	off = st->val.s;\n"
"\n"
"	if (*off == 't' || *off == 'T') {\n"
"		if (\n"
"				(*(++off) == 'r' || *off == 'R') &&\n"
"				(*(++off) == 'u' || *off == 'U') &&\n"
"				(*(++off) == 'e' || *off == 'E') &&\n"
"				(*(++off) == '\\0')\n"
"		) {\n"
"			free(st->val.s);\n"
"			st->val.b = true;\n"
"			return CONFCONF_SUCCESS;\n"
"		} else {\n"
"			return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"		}\n"
"	}\n"
"\n"
"	if (*off == 'y' || *off == 'Y') {\n"
"		if (\n"
"				(*(++off) == 'e' || *off == 'E') &&\n"
"				(*(++off) == 's' || *off == 'S') &&\n"
"				(*(++off) == '\\0')\n"
"		) {\n"
"			free(st->val.s);\n"
"			st->val.b = true;\n"
"			return CONFCONF_SUCCESS;\n"
"		} else {\n"
"			return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"		}\n"
"	}\n"
"\n"
"	if (*off == 'n' || *off == 'N') {\n"
"		if (\n"
"				(*(++off) == 'o' || *off == 'O') &&\n"
"				(*(++off) == '\\0')\n"
"		) {\n"
"			free(st->val.s);\n"
"			st->val.b = false;\n"
"			return CONFCONF_SUCCESS;\n"
"		} else {\n"
"			return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"		}\n"
"	}\n"
"\n"
"	if (*off == 'f' || *off == 'F') {\n"
"		if (\n"
"				(*(++off) == 'a' || *off == 'A') &&\n"
"				(*(++off) == 'l' || *off == 'L') &&\n"
"				(*(++off) == 's' || *off == 'S') &&\n"
"				(*(++off) == 'e' || *off == 'E') &&\n"
"				(*(++off) == '\\0')\n"
"		) {\n"
"			free(st->val.s);\n"
"			st->val.b = false;\n"
"			return CONFCONF_SUCCESS;\n"
"		} else {\n"
"			return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"		}\n"
"	}\n"
"\n"
"	if (*off == 'o' || *off == 'O') {\n"
"		if (\n"
"				(*(off+1) == 'n' || *(off+1) == 'N') &&\n"
"				(*(off+2) == '\\0')\n"
"		) {\n"
"			free(st->val.s);\n"
"			st->val.b = true;\n"
"			return CONFCONF_SUCCESS;\n"
"		}\n"
"\n"
"		if (\n"
"				(*(++off) == 'f' || *off == 'F') &&\n"
"				(*(++off) == 'f' || *off == 'F') &&\n"
"				(*(++off) == '\\0')\n"
"		) {\n"
"			free(st->val.s);\n"
"			st->val.b = false;\n"
"			return CONFCONF_SUCCESS;\n"
"		} else {\n"
"			return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"		}\n"
"	}\n"
"\n"
"	return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char sstring[] =
"#ifndef CONFCONF_STRING_H\n"
"#define CONFCONF_STRING_H\n"
"\n"
"static enum confconf_result_type confconf_priv_get_str(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	size_t len = 0, mlen = 0;\n"
"	char *stmp;\n"
"	int c, endc;\n"
"	bool escape = false;\n"
"\n"
"	st->val.s = NULL;\n"
"\n"
"	c = (*(st->gcp))(st->fp);\n"
"	if (c == EOF)\n"
"		return CONFCONF_ERR_UNEXPECTED_EOF;\n"
"\n"
"	if (c != '\\'' && c != '\\\"') {\n"
"		(*(st->ugcp))(c, st->fp);\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"	}\n"
"\n"
"	endc = c;\n"
"\n"
"	st->col++;\n"
"	st->byte++;\n"
"\n"
"	while (true) {\n"
"		c = (*(st->gcp))(st->fp);\n"
"		st->col++;\n"
"		st->byte++;\n"
"\n"
"		if (c == endc && !escape)\n"
"			break;\n"
"\n"
"		if (c == '\\\\' && !escape) {\n"
"			escape = true;\n"
"			continue;\n"
"		}\n"
"\n"
"		escape = false;\n"
"\n"
"		if (c == '\\n') {\n"
"			st->col = 1;\n"
"			st->line++;\n"
"		}\n"
"\n"
"		if (c == EOF) {\n"
"			if (st->val.s != NULL) {\n"
"				free(st->val.s);\n"
"				st->val.s = NULL;\n"
"			}\n"
"			return CONFCONF_ERR_UNEXPECTED_EOF;\n"
"		}\n"
"\n"
"		if (len == mlen) {\n"
"			mlen += CONFCONF_ALLOCWIDTH;\n"
"\n"
"			if (mlen < len) {\n"
"				if (st->val.s != NULL) {\n"
"					free(st->val.s);\n"
"					st->val.s = NULL;\n"
"				}\n"
"				return CONFCONF_ERR_MEMORY;\n"
"			}\n"
"\n"
"			stmp = realloc(st->val.s, mlen);\n"
"			if (stmp == NULL) {\n"
"				free(st->val.s);\n"
"				st->val.s = NULL;\n"
"				return CONFCONF_ERR_MEMORY;\n"
"			}\n"
"			st->val.s = stmp;\n"
"		}\n"
"\n"
"		st->val.s[len] = c;\n"
"		len++;\n"
"	}\n"
"\n"
"	if (len == mlen) {\n"
"		mlen += CONFCONF_ALLOCWIDTH;\n"
"\n"
"		if (mlen < len) {\n"
"			if (st->val.s != NULL) {\n"
"				free(st->val.s);\n"
"				st->val.s = NULL;\n"
"			}\n"
"			return CONFCONF_ERR_MEMORY;\n"
"		}\n"
"\n"
"		stmp = realloc(st->val.s, mlen);\n"
"		if (stmp == NULL) {\n"
"			free(st->val.s);\n"
"			st->val.s = NULL;\n"
"			return CONFCONF_ERR_MEMORY;\n"
"		}\n"
"		st->val.s = stmp;\n"
"	}\n"
"\n"
"	st->val.s[len] = '\\0';\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char sint[] =
"#ifndef CONFCONF_INT_H\n"
"#define CONFCONF_INT_H\n"
"\n"
"#include <errno.h>\n"
"#include <limits.h>\n"
"\n"
"static enum confconf_result_type confconf_priv_get_int(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	long int i;\n"
"	char *check;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	errno = EILSEQ;\n"
"	i = strtol(st->val.s, &check, 0);\n"
"\n"
"	if (errno == ERANGE)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	if (*check != '\\0')\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"\n"
"	if (i > INT_MAX || i < INT_MIN)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	free(st->val.s);\n"
"	st->val.i = (int)i;\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char sintl[] =
"#ifndef CONFCONF_INTL_H\n"
"#define CONFCONF_INTL_H\n"
"\n"
"#include <errno.h>\n"
"\n"
"static enum confconf_result_type confconf_priv_get_intl(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	long int il;\n"
"	char *check;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	errno = EILSEQ;\n"
"	il = strtol(st->val.s, &check, 0);\n"
"\n"
"	if (errno == ERANGE)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	if (*check != '\\0')\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"\n"
"	free(st->val.s);\n"
"	st->val.il = il;\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char sintll[] =
"#ifndef CONFCONF_INTLL_H\n"
"#define CONFCONF_INTLL_H\n"
"\n"
"#include <errno.h>\n"
"\n"
"static enum confconf_result_type confconf_priv_get_intll(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	long long int ill;\n"
"	char *check;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	errno = EILSEQ;\n"
"	ill = strtoll(st->val.s, &check, 0);\n"
"\n"
"	if (errno == ERANGE)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	if (*check != '\\0')\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"\n"
"	free(st->val.s);\n"
"	st->val.ill = ill;\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char suint[] =
"#ifndef CONFCONF_UINT_H\n"
"#define CONFCONF_UINT_H\n"
"\n"
"#include <errno.h>\n"
"#include <limits.h>\n"
"\n"
"static enum confconf_result_type confconf_priv_get_uint(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	long unsigned u;\n"
"	char *check;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	errno = EILSEQ;\n"
"	u = strtoul(st->val.s, &check, 0);\n"
"\n"
"	if (errno == ERANGE)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	if (*check != '\\0')\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"\n"
"	if (u > UINT_MAX)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	free(st->val.s);\n"
"	st->val.u = (unsigned)u;\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char suintl[] =
"#ifndef CONFCONF_UINTL_H\n"
"#define CONFCONF_UINTL_H\n"
"\n"
"#include <errno.h>\n"
"\n"
"static enum confconf_result_type confconf_priv_get_uintl(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	long unsigned ul;\n"
"	char *check;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	errno = EILSEQ;\n"
"	ul = strtoul(st->val.s, &check, 0);\n"
"\n"
"	if (errno == ERANGE)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	if (*check != '\\0')\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"\n"
"	free(st->val.s);\n"
"	st->val.ul = ul;\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char suintll[] =
"#ifndef CONFCONF_UINTLL_H\n"
"#define CONFCONF_UINTLL_H\n"
"\n"
"#include <errno.h>\n"
"\n"
"static enum confconf_result_type confconf_priv_get_uintll(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	long long unsigned ull;\n"
"	char *check;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	errno = EILSEQ;\n"
"	ull = strtoull(st->val.s, &check, 0);\n"
"\n"
"	if (errno == ERANGE)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	if (*check != '\\0')\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"\n"
"	free(st->val.s);\n"
"	st->val.ull = ull;\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char sfloat[] =
"#ifndef CONFCONF_FLOAT_H\n"
"#define CONFCONF_FLOAT_H\n"
"\n"
"#include <errno.h>\n"
"\n"
"static enum confconf_result_type confconf_priv_get_float(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	double f;\n"
"	char *check;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	errno = EILSEQ;\n"
"	f = strtof(st->val.s, &check);\n"
"\n"
"	if (errno == ERANGE)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	if (*check != '\\0')\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"\n"
"	free(st->val.s);\n"
"	st->val.f = f;\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char sdouble[] =
"#ifndef CONFCONF_DOUBLE_H\n"
"#define CONFCONF_DOUBLE_H\n"
"\n"
"#include <errno.h>\n"
"\n"
"static enum confconf_result_type confconf_priv_get_double(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	double d;\n"
"	char *check;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	errno = EILSEQ;\n"
"	d = strtod(st->val.s, &check);\n"
"\n"
"	if (errno == ERANGE)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	if (*check != '\\0')\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"\n"
"	free(st->val.s);\n"
"	st->val.d = d;\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char sdoublel[] =
"#ifndef CONFCONF_DOUBLEL_H\n"
"#define CONFCONF_DOUBLEL_H\n"
"\n"
"#include <errno.h>\n"
"\n"
"static enum confconf_result_type confconf_priv_get_doublel(\n"
"		struct confconf_priv_state *st)\n"
"{\n"
"	enum confconf_result_type r;\n"
"	double dl;\n"
"	char *check;\n"
"\n"
"	r = confconf_priv_get_tok(st);\n"
"\n"
"	if (r != CONFCONF_SUCCESS)\n"
"		return r;\n"
"\n"
"	errno = EILSEQ;\n"
"	dl = strtold(st->val.s, &check);\n"
"\n"
"	if (errno == ERANGE)\n"
"		return CONFCONF_ERR_RANGE;\n"
"\n"
"	if (*check != '\\0')\n"
"		return CONFCONF_ERR_UNEXPECTED_TOKEN;\n"
"\n"
"	free(st->val.s);\n"
"	st->val.dl = dl;\n"
"	return CONFCONF_SUCCESS;\n"
"}\n"
"\n"
"#endif\n"
"\n"
;

static const char shash[] =
"#ifndef CONFCONF_HASH_H\n"
"#define CONFCONF_HASH_H\n"
"\n"
"#include <uthash.h>\n"
"\n"
"#define CONFCONF_PRIV_GET_HASH_main(h, htmp, fun, mem) \\\n"
"	do { \\\n"
"		int c; \\\n"
"		char *hash_swp; \\\n"
"		(h) = NULL; \\\n"
"		c = (*(st.gcp))(st.fp); \\\n"
"		if (c != '[') { \\\n"
"			if (c == EOF) { \\\n"
"				r = CONFCONF_ERR_UNEXPECTED_EOF; \\\n"
"				st.val.s = NULL; \\\n"
"				break; \\\n"
"			} \\\n"
"			(*(st.ugcp))(c, st.fp); \\\n"
"			confconf_priv_get_tok(&st); \\\n"
"			r = CONFCONF_ERR_UNEXPECTED_TOKEN; \\\n"
"		} \\\n"
"		st.col++; \\\n"
"		st.byte++; \\\n"
"		while (1) { \\\n"
"			confconf_priv_eat_space(&st); \\\n"
"			r = confconf_priv_get_id(&st); \\\n"
"			if (r != CONFCONF_SUCCESS) \\\n"
"				break; \\\n"
"			HASH_FIND_STR((h), st.val.s, (htmp)); \\\n"
"			if ((htmp) != NULL) { \\\n"
"				r = CONFCONF_ERR_HASH_DUPLICATE_KEY; \\\n"
"				break; \\\n"
"			} \\\n"
"			hash_swp = st.val.s; \\\n"
"			confconf_priv_eat_space(&st); \\\n"
"			c = (*(st.gcp))(st.fp); \\\n"
"			if (c == ':') { \\\n"
"				st.col++; \\\n"
"				st.byte++; \\\n"
"				confconf_priv_eat_space(&st); \\\n"
"			} else { \\\n"
"				(*(st.ugcp))(c, st.fp); \\\n"
"				free(hash_swp); \\\n"
"				r = confconf_priv_get_tok(&st); \\\n"
"				if (r == CONFCONF_SUCCESS) \\\n"
"					r = CONFCONF_ERR_UNEXPECTED_TOKEN; \\\n"
"				break; \\\n"
"			} \\\n"
"			r = confconf_priv_get_ ## fun (&st); \\\n"
"			if (r != CONFCONF_SUCCESS) { \\\n"
"				free(hash_swp); \\\n"
"				break; \\\n"
"			} \\\n"
"			(htmp) = malloc(sizeof(*(htmp))); \\\n"
"			if ((htmp) == NULL) { \\\n"
"				free(hash_swp); \\\n"
"				r = CONFCONF_ERR_MEMORY; \\\n"
"				break; \\\n"
"			} \\\n"
"			(htmp)->key = hash_swp; \\\n"
"			(htmp)->val.mem = st.val.mem; \\\n"
"			HASH_ADD_STR((h), key, (htmp)); \\\n"
"			confconf_priv_eat_space(&st); \\\n"
"			c = (*(st.gcp))(st.fp); \\\n"
"			if (c == ',') { \\\n"
"				st.col++; \\\n"
"				st.byte++; \\\n"
"				confconf_priv_eat_space(&st); \\\n"
"			} else if (c == ']') { \\\n"
"				st.col++; \\\n"
"				st.byte++; \\\n"
"				r = CONFCONF_SUCCESS; \\\n"
"				break; \\\n"
"			} else { \\\n"
"				(*(st.ugcp))(c, st.fp); \\\n"
"			} \\\n"
"		} \\\n"
"	} while (0)\n"
"\n"
"#endif\n"
"\n"
;
