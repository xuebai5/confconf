#include "gen.h"

#include "version.h"
#include "parse.h"
#include "opt.h"

#include <time.h>
#include <assert.h>

#include "gen-consts.h"

void gen(FILE *f, struct parse_result_s pr, struct analyse_result_s ar)
{
	time_t t;
	struct tm *ti;

	struct parse_deftype_s *dcur, *dtmp;
	struct parse_var_s *vcur, *vtmp;

	unsigned i;

	time(&t);
	ti = localtime(&t);

	/********
	 * HEAD *
	 ********/

	fprintf(f, "/* generated by %s on %04d-%02d-%02d */\n", 
			VERSION, ti->tm_year + 1900, ti->tm_mon + 1, ti->tm_mday);

	fprintf(f, sheadp1);
	fprintf(f, sheadp2);

	if (ar.uses_type[PARSE_TYPE_BOOL])
		fprintf(f, sbool);
	if (ar.uses_type[PARSE_TYPE_STRING])
		fprintf(f, sstring);
	if (ar.uses_type[PARSE_TYPE_INT])
		fprintf(f, sint);
	if (ar.uses_type[PARSE_TYPE_INTL])
		fprintf(f, sintl);
	if (ar.uses_type[PARSE_TYPE_INTLL])
		fprintf(f, sintll);
	if (ar.uses_type[PARSE_TYPE_UINT])
		fprintf(f, suint);
	if (ar.uses_type[PARSE_TYPE_UINTL])
		fprintf(f, suintl);
	if (ar.uses_type[PARSE_TYPE_UINTLL])
		fprintf(f, suintll);
	if (ar.uses_type[PARSE_TYPE_FLOAT])
		fprintf(f, sfloat);
	if (ar.uses_type[PARSE_TYPE_DOUBLE])
		fprintf(f, sdouble);
	if (ar.uses_type[PARSE_TYPE_DOUBLEL])
		fprintf(f, sdoublel);

	/* if (ar.uses_array) */
	/* 	fprintf(f, sarray); */
	if (ar.uses_hash)
		fprintf(f, shash, (opt_header_str() ? opt_header_str() : pr.header));

	/********
	 * BODY *
	 ********/

	fprintf(f,
			"#ifndef CONFCONF_BODY_%s_H\n"
			"#define CONFCONF_BODY_%s_H\n\n",
			(opt_suffix_str() ? opt_suffix_str() : pr.suffix),
			(opt_suffix_str() ? opt_suffix_str() : pr.suffix)
	);

	/* deftypes */
	HASH_ITER(hh, pr.deftypes, dcur, dtmp) {
		if (!dcur->is_used)
			continue;

		fprintf(f, "%s confconf_type_%s_%s {\n",
				(dcur->type == PARSE_DEFTYPE_ENUM ? "enum" : 
					 (dcur->type == PARSE_DEFTYPE_UNION ?
					  "union" : "struct")
				),
				dcur->name,
				(opt_suffix_str() ? opt_suffix_str() : pr.suffix)
		);

		for (i = 0; i < dcur->member_list_len; i++) {
			if (dcur->type == PARSE_DEFTYPE_ENUM) {
				fprintf(f, "	CONFCONF_TYPE_%s_%s_%s,\n",
						dcur->name,
						dcur->member_name_list[i],
						(opt_suffix_str() ? opt_suffix_str() : pr.suffix)
				);
				continue;
			}

			switch (dcur->member_type_list[i]) {
			case PARSE_TYPE_BOOL:
				fprintf(f, "	bool ");
				break;
			case PARSE_TYPE_STRING:
				fprintf(f, "	char *");
				break;
			case PARSE_TYPE_ID:
				fprintf(f, "	char *");
				break;
			case PARSE_TYPE_INT:
				fprintf(f, "	int ");
				break;
			case PARSE_TYPE_INTL:
				fprintf(f, "	long int ");
				break;
			case PARSE_TYPE_INTLL:
				fprintf(f, "	long long int ");
				break;
			case PARSE_TYPE_UINT:
				fprintf(f, "	unsigned ");
				break;
			case PARSE_TYPE_UINTL:
				fprintf(f, "	long unsigned ");
				break;
			case PARSE_TYPE_UINTLL:
				fprintf(f, "	long long unsigned ");
				break;
			case PARSE_TYPE_FLOAT:
				fprintf(f, "	float ");
				break;
			case PARSE_TYPE_DOUBLE:
				fprintf(f, "	double ");
				break;
			case PARSE_TYPE_DOUBLEL:
				fprintf(f, "	long double ");
				break;
			default:
				assert(0);
			}

			fprintf(f, "%s;\n", dcur->member_name_list[i]);
		}

		fprintf(f, "};\n\n");
	}

	/* hash type */
	if (ar.uses_hash) {
		fprintf(f,
				"#include %s\n\n"
				"struct confconf_hash_%s {\n"
				"	char *key;\n"
				"	union {\n"
				"%s%s%s%s%s%s%s%s%s%s%s",
				(opt_header_str() ? opt_header_str() : pr.header),
				(opt_suffix_str() ? opt_suffix_str() : pr.suffix),
				(ar.uses_type[PARSE_TYPE_HASH_BOOL]
				 ? "		bool b;\n" : ""),
				(ar.uses_type[PARSE_TYPE_HASH_STRING]
				 ? "		char *s;\n" : ""),
				(ar.uses_type[PARSE_TYPE_HASH_INT]
				 ? "		int i;\n" : ""),
				(ar.uses_type[PARSE_TYPE_HASH_INTL]
				 ? "		long int il;\n" : ""),
				(ar.uses_type[PARSE_TYPE_HASH_INTLL]
				 ? "		long long int ill;\n" : ""),
				(ar.uses_type[PARSE_TYPE_HASH_UINT]
				 ? "		unsigned u;\n" : ""),
				(ar.uses_type[PARSE_TYPE_HASH_UINTL]
				 ? "		long unsigned ul;\n" : ""),
				(ar.uses_type[PARSE_TYPE_HASH_UINTLL]
				 ? "		long long unsigned ull;\n" : ""),
				(ar.uses_type[PARSE_TYPE_HASH_FLOAT]
				 ? "		float f;\n" : ""),
				(ar.uses_type[PARSE_TYPE_HASH_DOUBLE]
				 ? "		double d;\n" : ""),
				(ar.uses_type[PARSE_TYPE_HASH_DOUBLEL]
				 ? "		long double dl;\n" : "")
		);
		HASH_ITER(hh, pr.deftypes, dcur, dtmp) {
			if (dcur->is_used && dcur->is_in_hash) {
				fprintf(f, "		%s confconf_type_%s_%s type_%s;\n",
						(dcur->type == PARSE_DEFTYPE_ENUM ? "enum" : 
							 (dcur->type == PARSE_DEFTYPE_UNION ?
							  "union" : "struct")
						),
						dcur->name,
						(opt_suffix_str() ? opt_suffix_str() : pr.suffix),
						dcur->name
				);
			}
		}
		fprintf(f,
				"	} val;\n"
				"	UT_hash_handle hh;\n"
				"};\n\n"
		);

	}

	fprintf(f, "#endif\n");
}
